"""CryptoCheck - a small, fast cryptography checker for use with SARIF files generated by
CodeQL queries defined by Microsoft and GitHub as part of the Pre-Quantum Research project."""

import ast
import json
from decimal import Decimal
from pathlib import Path

import jsonschema
import yaml
from cyclonedx.model import XsUri
from cyclonedx.model.vulnerability import BomTarget, Vulnerability, VulnerabilityAdvisory, VulnerabilityRating, \
    VulnerabilitySeverity, VulnerabilitySource

from cbom.cryptocheck import sarif, validators

"""
All rules are in the form match_type(criteria, target_to_check)
"""

_VALIDATORS = {
    'r': validators.does_match_regex,
    's': validators.does_contain,
    'lt': validators.is_less_than,
    'gt': validators.is_greater_than,
    'lteq': validators.is_less_than_or_equal,
    'gteq': validators.is_greater_than_or_equal,
    'eq': validators.is_equal,
    'neq': validators.is_not_equal
}


def validate_cbom(cbom, rules_file=None, *, enrich_cbom=True):
    """
    compare everything to everything
    """
    rules = _load_rules(rules_file)

    rule_violations = []
    for rule in rules:
        non_compliant_components = []
        algorithm_components = (c for c in cbom.components if c.type == 'crypto-asset' and c.crypto_properties.asset_type == 'algorithm')

        for algorithm_component in algorithm_components:
            algorithm_properties = algorithm_component.crypto_properties.algorithm_properties
            variant = algorithm_properties.variant.split('-')
            variant = {
                'algo': variant[0],
                'keylen': int(variant[1]) if len(variant) > 1 and variant[1].isnumeric() else None,
                'mode': algorithm_properties.mode,
                'padding': algorithm_properties.padding
            }

            is_match = map(lambda pattern: _VALIDATORS[pattern[1]](pattern[2], variant[pattern[0]]), rule['patterns'])
            if all(is_match):
                non_compliant_components.append(algorithm_component.bom_ref)

        if non_compliant_components:  # todo: handle default
            rule_violations.append({
                'name': rule['name'],
                'detection': rule['detection'],
                'bom-refs': non_compliant_components
            })

    if enrich_cbom:
        _add_vulnerabilities_to_cbom(cbom, rule_violations)
    return sarif.build_cryptocheck_sarif(cbom, rules, rule_violations)


def _load_rules(file_path=None):
    if not file_path:
        file_path = Path(__file__).absolute().parent.parent / 'resources/cryptocheck_rules.yml'

    with (
        open(file_path) as rules,
        open(Path(__file__).absolute().parent.parent / 'resources/cryptocheck_schema.json') as schema
    ):
        rules = yaml.safe_load(rules)
        jsonschema.validate(rules, json.load(schema))
        for rule in rules:
            rule['patterns'] = [ast.literal_eval(pattern) for pattern in rule['patterns']]
    return rules


def _add_vulnerabilities_to_cbom(cbom, rule_violations):
    for violation in rule_violations:
        affected_components = [BomTarget(ref=bom_ref.value) for bom_ref in violation['bom-refs']]
        rating = VulnerabilityRating(
            source=VulnerabilitySource(
                url=XsUri('To follow'),  # todo
                name='cryptocheck from SAN, MS, GH'  # todo
            ),
            score=Decimal(violation['detection']['severity']),
            severity=_get_severity_from_score(violation['detection']['severity'])
        )

        cbom.vulnerabilities.add(Vulnerability(
            bom_ref=f"cryptocheck:{violation['name']}",
            id=violation['name'],
            ratings=[rating],
            cwes=[],  # todo
            description=violation['detection']['description'],
            recommendation='Please review the use of cryptography, and make plans according to best practices.',
            advisories=[
                VulnerabilityAdvisory(url=XsUri('To follow'))  # todo
            ],
            # published='2023-12-05T09:00:00.000Z',  # todo
            affects=affected_components
        ))


def _get_severity_from_score(score):
    match score:
        case score if score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        case score if score >= 7.0:
            return VulnerabilitySeverity.HIGH
        case score if score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        case score if score < 4.0:
            return VulnerabilitySeverity.LOW
        case _:
            return VulnerabilitySeverity.INFO
